盛放记录的大盒子 -InnoDB数据页结构

delete_mask

标记当前记录是否被删除占用一个二进制位，0-表示未被删除

所有被删除的记录会组成一个垃圾链表，所占用空间为 可重用空间

* 垃圾链表存放在哪？
* 将delete_mask设置为1和将被删除记录加入到垃圾链表其实是两个阶段

heap_no

占用13位 因此一个页中最多存放记录 2^13条记录

两条伪记录，最大记录+最小记录

用户的记录是一个单链表

最小记录 ->id最小的userRecords ->id最大的userRecord->最大记录

当数据页中存在多条被删除记录时，这些记录的next_record属性会把这些删除掉的记录组成一个垃圾链表，以备不时之需

Page Directory（页目录）

1. 将所有正常的记录（包括最大和最小记录，不包括已删除的记录）划分为几个组

2. 每个组的最后一条记录（也就是组内最大的那条记录）的记录头信息中的n_owned标示该组拥有几条记录

3. 将每个组最后一条记录的地址偏移量单独提取出来，按顺序存储到靠近页的尾部的位置，这个地方就是所谓的Page Directory，也就是页目录。页目录中这些地址偏移量被称为槽，这个页面目录是由槽组成

   地址偏移量称之为槽

分组：

最小记录所在的分组只能有1条记录

最大记录所在的分组只能在1-8条

剩下的分组记录的条数范围只能是4-8

初始情况下一个数据页只有最小纪录和最大记录，他们属于两个组

查找记录的过程：

通过二分法确定记录所在槽的位置

然后通过链表查询记录

Page Header（页面头部）

记录当前页的状态信息

| 名称              | 占用空间大小 | 描述                                           |
| ----------------- | ------------ | ---------------------------------------------- |
| PAGE_N_DIR_SLOTS  | 2            | 槽数量                                         |
| PAGE_HEAP_TOP     | 2            | 未使用空间最小地址                             |
| PAGE_N_HEAP       | 2            | 本页中记录的数量(包含删除的是数量)             |
| PAGE_FREE         | 2            | 第一个已经被删除的地址                         |
| PAGE_GARBAGE      | 2            | 已删除记录占用字节数                           |
| PAGE_LAST_INSERT  | 2            | 最后插入记录的位置                             |
| PAGE_DIRECTION    | 2            | 记录插入的方向                                 |
| PAGE_N_DIRECTION  | 2            | 一个方向连续插入的数量                         |
| PAGE_N_RECS       | 2            | 该页中记录的数量                               |
| PAGE_MAX_TRX_ID   | 2            | 修改当前页最大的事务ID，该值仅在二级索引中定义 |
| PAGE_LEVEL        | 2            | 当前页在B+树种所处的层级                       |
| PAGE_INDEX_ID     | 8            | 索引ID，当前页属于哪个索引                     |
| PAGE_BTR_SEG_LEVF | 10           | B+树叶子端头部信息，仅在B+树ROOT页定义         |
| PAGE_BTR_SEG_TOP  | 10           | B+树非叶子段头部信息，仅在B+树的Root页定义     |

PAGE_N_DIR_SLOTS    2  页目录中槽数量

PAGE_HEAP_TOP   



File Trailer

8个字节

前四个字节 校验和

后四个字节代表页面最后被修改时对应的日志序列位置

File Trailer 与File Header是通用的

一个数据页被分为7部分

File Header 38字节 记录通用信息 校验和 当前页号 上一页 下一页 最后被修改时日志序列位置 页面的类型 页属于哪个表空间

Page Header 当前页所有记录数 最大值 最小值

Infimum + supremum 伪记录 最小纪录和最大记录

User Records 用户记录 单链表

通过二分法确定槽 遍历记录查找到记录

Free Space 可用空间 

Page Directory 页目录 槽

File Trailer 校验和 页面被修改时日志序列位置

B+树索引

页组成双向链表

页内记录是一个单向链表



可变列长度 Null值列表   记录头

record 0表示普通记录2表示最小记录 3表示最大记录



快速定为记录所在的数据页建立一个别的目录

1.下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值

页面记录的移动称之为页分裂

2.给所有的页建立一个目录项，每个目录项包括两部分

* 页中的用户记录中最小的主键值
* 页号

目录项1   目录项2

我们只需要把目录项在物理存储器上连续存储，比如把他们放在一个数组里，就可以根据主键值快速定为某条记录了

1.先从目录项根据二分法快速确定主键值所在的目录项中，根据目录项找到对应的页

innodb是根据页来管理存储空间的基本单位，最多能保证26kb的连续空间

2.复用数据页来存储目录页 两个列为主键和页号

* 0:用户的普通记录
* 1：目录项记录
* 2：最小记录
* 3：最大记录

确定目录项记录也

根据目录项记录页确定用户真实记录所在页

在用户真实记录所在页定为到具体的记录

内节点(非叶子节点) 叶子节点 根节点

一般B+树不会超过4层，因此只需要查询4次就可以查询到真实的记录



聚簇索引叶子节点存放的是完整的数据

二级索引叶子节点存储的不是完整的用户记录 只是 索引列+主键 这两个列的值

二级索引查询数据需要到聚簇索引中重新查询一次 这称之为回表

根据二级索引查询一条完整的记录 需要查询两颗b+树



联合索引

注意事项：

一个B+树的根节点从诞生之日起，便不会再移动

内节点中目录项记录的唯一性

二级索引目录项的内容：索引列的值 主键值 页号

一个InnoDB的数据页最少可以存放两条记录



MyISAM 存储引擎

索引文件+数据文件



索引的代价

空间上代价 一个节点对应一个页一个页占用16kb

时间上代价

修改删除数据时 需要维护B+树的索引树



回表的代价

回表由于主键不是顺序排列的，如果回表的数据过多，就会采用全表扫描的方式进行优化

假如添加一些 limit 后 能够增加概率采用索引



如何挑选索引：

只为用于搜索，排序或分组的列创建索引

考虑列的基数

列的基数是指某一列中不重复数据的个数

最好为那些列的基数大的列建立索引

索引列的类型要尽量小

这个建议对于主键更为适用，因为主键不仅在聚簇索引中，也会在二级索引中

索引字符串的前缀

如果字符串过长可以定义只采用多少长度的前缀当做索引

索引列前缀对排序的影响

如果采用了索引列排序，那么orderBy 时就不能使用索引列进行排序了，只能使用文件排序

让索引列在表达式中单独出现

where my_col*2 < 4   where my_col < 4/2

主键的插入顺序

主键在聚簇索引中是按照从小到大的，如果主键值忽大忽小的话，会造成很多页分裂行为，因此主键值采用自增的比较好

show variables like 'dataDir'



数据库目录 表文件 ***.ibd

文件系统对数据库的影响

* 数据库名称和表名称不得超过文件系统所允许的最大长度
* 特殊字符的问题
* 文件长度受文件系统最大长度限制

变长字段长度列表  null值列表 记录头 真实数据值

变长字段长度列表

真正的数据内容

占用的字节数

但是具体用一个字节还是2个字节 InnoDB有自己的一套记录公式

W(一个字符最多使用的字节) M(一个字段最多占用的字符) L(真实占用的字节数)

MXW <255

InnoDB在读记录的变长字段长度列表时会先看表结构，如果某个变长字段允许存储的最大字节数<255时就会采用一个字节

MXW >255则分为两种情况

如果L <=127 则用一个字节来表示真正字符串占用的字节数

如果L> 127

变长字段列表(每个字段)最多占用2个字节

null值列表（每个字段占用1位）但是整体要占用整个字段长度，不够的补0

记录头信息 占用5个字节

预留位1

预留位2

delete_mask

min_rec_mask

n_owned

heap_no 表示当前记录在记录堆中的位置

record_type 0普通记录 1内节点 2最小记录 3最大记录

next_record 下一条记录相对位置

记录的真实数据 

row_id DB_ROW_ID transaction_id DB_TRX_ID DB_ROLL_PTR

CHAR(M)最少占用10个字节



一个页最多存放16384个字节 （16KB）varchar(65532)最多存储65532个字节，这样就造成一个页存放不下

一条记录的情况 那么就会产生溢出页，在记录真实数据处理会采用20个地址存放溢出页的地址

访问方法

const

主键 唯一二级索引列 （等值查询），但是对于Null的查询不是这样的，

ref 

普通的二级索引进行等值查询（如果匹配二级索引记录太多那么回表的成本就太大了）

二级索引列为Null的情况

2级索引为Null时 最多采用ref的方法

ref_or_null

where a= '' or b is null

采用二级索引而不是全表扫描的方式时是这种

range 

利用索引 进行范围匹配的访问方法称之为 range

这里的范围查询 既可以是聚簇索引 也可以是二级索引

单点区间 连续范围区间

index

select key_part1,key_part_2 where key_part2=111

不需要进行回表操作的称之为index(遍历二级索引记录的方式)

all

全表扫描

重温 二级索引 +回表

key1='abc'

key2 > 1000

一般情况下只会采用一个索引字段

明确range方法的范围区间

对于B+树索引来说 只要索引列和常熟使用 = <=> in not in is null is not null < > >= <= between !=

或者like操作反连接起来

索引合并 分为三种情况
intersection

可能出现的场景

* 二级索引列是等值匹配的情况下，对于联合索引来说，联合索引中的每个列都必须是等值匹配，不能出现只匹配部分列的情况
* 主键列可以使范围匹配

union 合并

union

* 二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中每个列比速时等值匹配

* 主键是范围匹配的范式
* 使用intersection索引合并的搜索条件

Sort-Union 合并

对应的主键范围查询 扩大了 intersection的使用条件

采用联合索引替代索引合并

连接的简介

笛卡尔积

内连接

外连接

​	驱动表中 on 条件对应的被驱动表没有对应的数据 也会将驱动表进行展示，被驱动表字段为null

​	左外连接 左边表为驱动表

​    右外连接  右边表为驱动表

驱动表只会查询一次，被驱动表会被查询n次

嵌套循环连接

使用索引加快连接速度

基于块的嵌套循环连接

MySQL基于成本的优化

const ref ref_or_null range index all

聚合索引

intersection

union

sort-union

I/O成本

CPU成本

server_cost

engine_cost







